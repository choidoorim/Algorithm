#<코드잇>
#정수: int/실수: float
#~(bitwise not), &(bitwise and), |(bitwise or), ^(bitwise xor),
#<<(bitwise left shift), >>(bitwise right shift) -> 비트단위 연산자.
#float 와 double의 차이점은 double이 수의 오차범위가 더 작다라는 것이다.
# a ** b -> a^b 이다.
def codeup_06():
    print("\"!@#$%^&*()\'")

def codeup_19():
    y, m, d = input().split('.')
    print(d, m, y, sep='-')

def codeup_23():
    a,b,c = input().split(':')
    print(b)

def codeup_24():
    word1, word2 = input().split()
    s = word1 + word2
    print(s)

def codeup_25():
    word1, word2 = input().split()
    s = int(word1) + int(word2)
    print(s)

def codeup_26():
    word1 = input()
    word2 = input()
    s = float(word1) + float(word2)
    print(s)

def codeup_27():
    word1 = input()
    a = int(word1)
    print('%x' % a)

# %x -> 소문자 출력, %X -> 대문자 출력
def codeup_28():
    word1 = input()
    a = int(word1)
    print('%X' % a)

def codeup_29():
    word1 = input()
    a = int(word1, 16)  # 입력된 a를 16진수로 변환
    print('%o' % a)

#UniCode: 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하는 것.
def codeup_30():
    word1 = ord(input()) #unicode로 입력 받은 문자를 변환.
    print(word1)

def codeup_31():
    word1 = int(input())
    print(chr(word1))

def codeup_32():
    word1 = int(input())
    print(-word1)

def codeup_33():
    word1 = ord(input())  # unicode로 입력 받은 문자를 변환.
    word2 = word1 + 1
    print(chr(word2))

def codeup_34():
    a, b = input().split()
    c = int(a) - int(b)
    print(c)

def codeup_35():
    a, b = input().split()
    c = float(a) * float(b)
    print(c)

def codeup_36():
    word1, n = input().split()
    print(word1 * int(n))

def codeup_37():
    n = input()
    word1 = input()
    print(int(n)* word1)

def codeup_38():
    w1, w2 = input().split()
    print(int(w1)**int(w2))

def codeup_39():
    w1, w2 = input().split()
    print(float(w1) ** float(w2))

def codeup_40():
    w1, w2 = input().split()
    print(int(w1)//int(w2)) # '//'연산자는 몫을 계산해준다.

def codeup_41():
    w1, w2 = input().split()
    print(int(w1)%int(w2))

def codeup_42(): #정확도 측정은 round를 통해 계산해야한다.
    w1 = input()
    print(round(float(w1), 2))

def codeup_43():
    w1, w2 = input().split()
    result = float(w1)/float(w2) #실수가 컴퓨터에 저장되는 과정에서 잘림 오차가 자주 발생한다.
    print('%.3f'%result)

def codeup_44():
    w1, w2 = input().split()
    print(int(w1) + int(w2))
    print(int(w1) - int(w2))
    print(int(w1) * int(w2))
    print(int(w1) // int(w2))
    print(int(w1) % int(w2))
    result = float(w1) / float(w2)
    print(round(float(result), 2))

def codeup_45():
    w1, w2, w3 = input().split()
    sum = int(w1) + int(w2) + int(w3)
    rv = sum/3
    print(sum, round(rv, 2))

def codeup_46():
    n = input()
    shift = int(n) << 1 # << 왼쪽 쉬프트. >> 오른쪽 쉬프트.
    print(shift)

def codeup_47():
    n1, n2 = input().split()
    print(int(n1) << int(n2))

def codeup_48():
    n1, n2 = input().split()
    print(int(n1) < int(n2)) #비교/관계연산자는 <, >, <=, >=, ==(같다), !=(다르다)

def codeup_49():
    n1, n2 = input().split()
    print(int(n1) == int(n2))

def codeup_50():
    n1, n2 = input().split()
    print(int(n1) <= int(n2))

def codeup_51():
    n1, n2 = input().split()
    print(int(n1) != int(n2))

def codeup_52():
    n = int(input())
    print(bool(n)) #python에서 0 값은 false 그리고 나머지 값들은 true로 판단.

def codeup_53():
    n = bool(int(input()))
    print(not n) #true, false와 같은 논리 연산 값을 반대로 바꿔준다.

def codeup_54():
    n1, n2 = input().split()
    print(bool(int(n1)) and bool(int(n2))) #python이 괄호를 해석하는 순서는 안에서 밖이다. EX) input -> bool

def codeup_55():
    n1, n2 = input().split()
    print(bool(int(n1)) or bool(int(n2)))

def codeup_56():
    n1, n2 = input().split()
    print((bool(int(n1)) and (not bool(int(n2)))) or ((not bool(int(n1))) and bool(int(n2)))) # XOR

def codeup_57():
    n1, n2 = input().split() #논리연산 문제가 나올 때는 그림을 그려보다. 반도체 수업 때를 생각. EX) or Gate/ and Gate...
    print((bool(int(n1)) or (not bool(int(n2)))) and  ((not bool(int(n1))) or bool(int(n2))))

def codeup_58():
    n1, n2 = input().split()
    print(not(bool(int(n1)) or bool(int(n2))) and not(bool(int(n1)) or bool(int(n2))))

def codeup_59():
    n1 = int(input().split()) #str형을 비트연산자를 사용할라고 하니 에러 발생.
    print(~n1) #bit 연산자 '~'은 비트를 반대로 연산해주는 not기능이다.

def codeup_60():
    n1, n2 = input().split() #split를 사용할 때 입력 받은 값을 int형으로 변환하는 작업을 해줘야 한다.
    n1 = int(n1)
    n2 = int(n2)
    print(n1 & n2)

def codeup_61():
    n1, n2 = input().split()
    n1 = int(n1)
    n2 = int(n2)
    print(n1 | n2)

def codeup_62():
    n1, n2 = input().split()
    n1 = int(n1)
    n2 = int(n2)
    print(n1 ^ n2)

def codeup_63():
    n1, n2 = input().split()
    n1 = int(n1)
    n2 = int(n2)
    if(n1 > n2):
        print(n1)
    else:
        print(n2)

def codeup_63_1():
    n1, n2 = input().split()
    n1 = int(n1)
    n2 = int(n2)
    result = (n1 if (n1 > n2) else n2) #3항 연산, 경우에 따라 코드를 줄일 수 있다.
    print(result)

def codeup_64():
    n1, n2, n3 = input().split()
    n1 = int(n1)
    n2 = int(n2)
    n3 = int(n3)
    print((n2 if(n1 > n2) else n1) if((n2 if(n1 > n2) else n1)) < n3 else n3)

def codeup_64_1(): #3항 연산자를 활용하면 경우에 따라 코드의 길이를 확실히 줄일 수 있다.
    n1, n2, n3 = input().split()
    n1 = int(n1)
    n2 = int(n2)
    n3 = int(n3)
    if(n1 > n2):
        small = n2
        if(small < n3):
            small = small
        else:
            small = n3
    elif(n1 < n2):
        small = n1
        if (small < n3):
            small = small
        else:
            big = n3
    print(int(small))

def codeup_65():
    n1, n2, n3 = input().split()
    n1 = int(n1)
    n2 = int(n2)
    n3 = int(n3)
    if (n1 % 2 == 0):
        print(int(n1))
    if (n2 % 2 == 0):
        print(int(n2))
    if (n3 % 2 == 0):
        print(int(n3))


def num(number):
    if(number % 2 == 0):
        print("even")
    else:
        print("odd")
def codeup_66():
    n1, n2, n3 = input().split()
    num(int(n1))
    num(int(n2))
    num(int(n3))


def Judge(num):
    if(num % 2 == 0 and num < 0):
        print("A")
    elif(num % 2 != 0 and num < 0):
        print("B")
    elif(num % 2 == 0 and num > 0):
        print("C")
    else:
        print("D")
def codeup_67():
    n1 = int(input())
    Judge(n1)


def ev(num):
    if(num >= 90):
        print("A")
    elif(90 > num >= 70):
        print("B")
    elif(70 > num >= 40):
        print("C")
    else:
        print("D")
def codeup_68():
    n1 = int(input())
    ev(n1)

def codeup_69():
    n1 = str(input())
    if(n1 == "A"):
        print("best!!!") # good!! run! slowly~
    elif(n1 == "B"):
        print("good!!")
    elif(n1 == "C"):
        print("run!")
    elif(n1 == "D"):
        print("slowly~")
    else:
        print("what?")

def season(num):
    if(num == 1 or num == 12 or num == 2):
        print("winter")
    elif (num == 3 or num == 4 or num == 5):
        print("spring")
    elif (num == 6 or num == 7 or num == 8):
        print("summer")
    elif (num == 9 or num == 10 or num == 11):
        print("fall")
    else:
        print("Not Season.")
def season_2(num): #공통적으로 개월은 나눴을 때 몫이 계절별로 같다.
    if(num == 12):
        num = 1
    else:
        num = int(num)
    result = num/3
    result = int(result)
    if(result == 0): #12는 몫이 4이므로 예외처리 해줘야 한다.
        print("winter")
    elif(result == 1):
        print("spring")
    elif(result == 2):
        print("summer")
    elif(result == 3):
        print("fall")
    else:
        print("Not Season")
def codeup_70():
    n1 = int(input())
    season(n1)
    season_2(n1)

def codeup_71():
    n1 = 1 #초기 값
    while n1!=0:
        n1 = int(input()) #키보드를 통해 입력하는 숫자는 형변환을 해주지 않으면 str형으로 입력이 된다.
        print(type(n1))
        if(n1!=0):
            print(n1)

def codeup_72():
    n1 = int(input())
    while n1!=0:
        print(n1)
        n1 = n1 - 1

def codeup_73():
    n1 = int(input())
    while n1 != 0:
        n1 = n1 - 1
        print(n1)

def codeup_74(): #ord(): 문자를 아스키코드 값으로 변환해주는 함수, chr():아스키코드 값을 문자로 변환해주는 함수
    n1 = ord(input())
    n2 = ord('a') #초기 값 a의 아스키코드
    while n2<=n1:
        print(chr(n2), end=' ') # print(..., end=' ')로 입력 시 줄을 바꾸지 않고 공백문자를 출력한다.
        n2 += 1

def codeup_75():
    n1 = int(input())
    n2 = 0
    while n2<=n1:
        print(n2)
        n2 += 1

def codeup_76(): #반복문 변수의 순서는 i,j,k..알파벳순으로 사용한다.
    n1 = int(input())
    for i in range(n1+1): # range(n) 함수는 0 ~ n-2, n-1 까지의 수열을 의미한다.
        print(i)

def codeup_77():
    n1 = int(input())
    sum = 0
    for i in range(n1+1):
        if(i % 2 == 0):
            sum += i
    print(sum)

def codeup_78():
    n1 = ''
    while n1 != 'q':
        n1 = input()
        print(n1)

def codeup_78_1():
    n1 = input().split()
    for i in n1:
        print(i)
        if(i =='q'):
            break

def codeup_79():
    n1 = int(input())
    sum = 0
    i = 0
    while n1 > sum:
        i += 1
        sum = sum + i
    print(i)

def codeup_80():
    n1, n2 = input().split()
    n1 = int(n1)
    n2 = int(n2)
    for i in range(1, n1+1): # 1 ~ n1까지
        for j in range(1, n2+1): # 1 ~ n2까지
            print(i, j)

def codeup_81():
    n1 = input()
    n1 = int(n1, 16) # n1을 16진수로 변환.
    for i in range(1, 16): #i는 int형이다.
        print('%X*%X=%X'%(n1,i,(n1*i)))
        #print('%X'%n1,'*%X ='%i,' %X'%(n1*i), sep='') #sep='' : 공백 없이 붙여서 출력해준다.

def codeup_82(): #비효율적인 코드
    n1 = int(input())
    j = 0
    for i in range(1, n1 + 1):
        j += 1 #1의 자리수만 계산하기 위한 변수
        if(j==11):
            j = 1
        if(j%3 == 0):
            print('X', end=' ')
        else:
            print(i, end=' ')
def codeup_82_1():
    n1 = int(input())
    for i in range(1, n1 + 1):
        if(i%10 == 3 or i%10 == 6 or i%10 == 9):
            print('X', end=' ')
        else:
            print(i, end=' ')

def codeup_83(): #반복문을 통해 데이터를 변수에 넣고 한번에 출력하는 것이 매번 출력하는 것보다 빠르다.
    n1, n2, n3 = map(int, input().split())
    ic = 0
    for i in range(n1):
        for j in range(n2):
            for k in range(n3):
                print('{} {} {}'.format(i,j,k)) #print(i,j,k)보다 format을 통해 출력하는 것이 더 빠르다.
                ic += 1
    print(ic)

def codeup_84():
    h,b,c,s = map(int, input().split())
    result = round(float(h*b*c*s/8/1024/1024), 1)
    print('{} MB' .format(result))

def codeup_85():
    w,h,b = map(int, input().split())
    result = w*h*b/8/1024/1024
    print('%.2f MB' %result)

def codeup_86():
    n1 = int(input())
    ic = 0
    sum = 0
    while True:
        ic += 1
        sum += ic
        if(sum >= n1):
            print(sum)
            break

def codeup_87():
    n1 = int(input())
    for i in range(1, n1+1):
        if(i%3 == 0):
            continue #조건문이나 반복문에 continue가 실행되면 다음 반복단계로 넘어간다.
            print(type(n1)) #실행되지 않고 넘어간다.
        else:
            print(i, end=' ')

def codeup_88(): #등차수열
    a, d, n = map(int, input().split())
    result = a + (n-1)*d
    print(result)

def codeup_89(): #등비수열
    a, r, n = map(int, input().split())
    result = a*(r**(n-1))
    print(result)

def codeup_90(): #수열
    a, m, d, n = map(int, input().split())
    for i in range(1, n): #a 값에서부터 반복문이 1번 실행된것과 같다.
        seq = a * m + d
        a = seq  # 결과 값을 저장.
    print(a) # 1 -1 1 1을 넣었을 때는 1번째 순서이므로 반복문이 돌지 않고 실행되는 것과 같으므로 seq가 아닌 a를 출력해야한다.

def codeup_91(): #나머지 값을 통해서 최소공배수를 계산할 수 있다.
    a, b, c = map(int, input().split())
    ic = 1
    while (ic%a != 0 or ic%b != 0 or ic%c != 0):
        ic += 1
    print(ic)

def codeup_91_1():
    a, b, c = map(int, input().split())
    ic = 1
    while True:
        ic += 1
        if(ic%a == 0 and ic%b == 0 and ic%c == 0):
            break
    print(ic)

def codeup_92():
    n = int(input())
    a = input().split()
    for i in range(0, n): #n번 a 번호를 입력하여 저장
        a[i] = int(a[i])

    d=[]
    for i in range(24): #count된 수를 담을 list
        d.append(0)

    for i in range(n): #a list에 값이 있을 때마다 d list의 해당 숫자 count
        d[a[i]] += 1

    for i in range(1, 24):
        print(d[i], end=' ')


codeup_92()